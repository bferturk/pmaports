From 045eeac5f4becc8d1fb807191719a9d5c0721549 Mon Sep 17 00:00:00 2001
Message-Id: <045eeac5f4becc8d1fb807191719a9d5c0721549.1516189772.git.mirq-linux@rere.qmqm.pl>
In-Reply-To: <ca5e9bd6560a188703123bcef6012ce2efa71aaf.1516189772.git.mirq-linux@rere.qmqm.pl>
References: <ca5e9bd6560a188703123bcef6012ce2efa71aaf.1516189772.git.mirq-linux@rere.qmqm.pl>
From: =?UTF-8?q?Micha=C5=82=20Miros=C5=82aw?= <mirq-linux@rere.qmqm.pl>
Date: Wed, 4 Oct 2017 22:06:47 +0200
Subject: [PATCH 47/52] input: Support Asus TF300T MobileDock inputs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add drivers for Asus TF300T keyboard and touchpad. This looks like
an i8042-compatible part with atkbd + elan touchpad parts and additional
line of special keys.

Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
---
 drivers/input/keyboard/Kconfig           |  10 ++
 drivers/input/keyboard/Makefile          |   1 +
 drivers/input/keyboard/asusec-ext-keys.c | 177 +++++++++++++++++++++++++++++++
 drivers/input/serio/Kconfig              |  15 +++
 drivers/input/serio/Makefile             |   1 +
 drivers/input/serio/asusec-kbc.c         | 141 ++++++++++++++++++++++++
 6 files changed, 345 insertions(+)
 create mode 100644 drivers/input/keyboard/asusec-ext-keys.c
 create mode 100644 drivers/input/serio/asusec-kbc.c

diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index 4c4ab1ced235..11795ba260d3 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -70,6 +70,16 @@ config KEYBOARD_AMIGA
 config ATARI_KBD_CORE
 	bool
 
+config KEYBOARD_ASUSEC
+	tristate "Asus Transformer Mobile Dock multimedia keys"
+	depends on MFD_ASUSEC
+	help
+	  Say Y here if you want to use multimedia keys present on Asus
+	  Transformer Pad's Mobile Dock.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called asusec-ext-keys.
+
 config KEYBOARD_ATARI
 	tristate "Atari keyboard"
 	depends on ATARI
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index d2338bacdad1..1bca9fb6a3b6 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_KEYBOARD_ADP5520)		+= adp5520-keys.o
 obj-$(CONFIG_KEYBOARD_ADP5588)		+= adp5588-keys.o
 obj-$(CONFIG_KEYBOARD_ADP5589)		+= adp5589-keys.o
 obj-$(CONFIG_KEYBOARD_AMIGA)		+= amikbd.o
+obj-$(CONFIG_KEYBOARD_ASUSEC)		+= asusec-ext-keys.o
 obj-$(CONFIG_KEYBOARD_ATARI)		+= atakbd.o
 obj-$(CONFIG_KEYBOARD_ATKBD)		+= atkbd.o
 obj-$(CONFIG_KEYBOARD_BCM)		+= bcm-keypad.o
diff --git a/drivers/input/keyboard/asusec-ext-keys.c b/drivers/input/keyboard/asusec-ext-keys.c
new file mode 100644
index 000000000000..8fb8d7b30e8f
--- /dev/null
+++ b/drivers/input/keyboard/asusec-ext-keys.c
@@ -0,0 +1,177 @@
+/*
+ * ASUS Transformer Pad - multimedia keys
+ *
+ * Written by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
+ *
+ * Copyright (C) 2017 Michał Mirosław
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/mfd/asusec.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#define ASUSEC_EXT_KEY_CODES 0x20
+
+struct asusec_keys_data
+{
+	struct notifier_block	  nb;
+	const struct asusec_info *ec;
+	struct input_dev	 *xidev;
+	unsigned short		  keymap[ASUSEC_EXT_KEY_CODES];
+};
+
+static const unsigned short asusec_dock_ext_keys[] = {
+	[0x01] = KEY_SCREENLOCK,
+	[0x02] = KEY_WLAN,
+	[0x03] = KEY_BLUETOOTH,
+	[0x04] = KEY_TOUCHPAD_TOGGLE,
+	[0x05] = KEY_BRIGHTNESSDOWN,
+	[0x06] = KEY_BRIGHTNESSUP,
+	[0x07] = KEY_BRIGHTNESS_AUTO,
+	[0x08] = KEY_CAMERA,
+	[0x10] = KEY_WWW,
+	[0x11] = KEY_CONFIG,
+	[0x12] = KEY_PREVIOUSSONG,
+	[0x13] = KEY_PLAYPAUSE,
+	[0x14] = KEY_NEXTSONG,
+	[0x15] = KEY_MUTE,
+	[0x16] = KEY_VOLUMEDOWN,
+	[0x17] = KEY_VOLUMEUP,
+};
+
+#define INPUT_SETUP_KEYMAP(d, kmap, kmap_src) do { \
+	struct input_dev *dev = (d); \
+	BUILD_BUG_ON(ARRAY_SIZE(kmap) < ARRAY_SIZE(kmap_src)); \
+	dev->keycode = kmap; \
+	dev->keycodesize = sizeof(*kmap); \
+	dev->keycodemax = ARRAY_SIZE(kmap); \
+	asusec_keys_setup_keymap(dev, kmap_src, ARRAY_SIZE(kmap_src)); \
+} while (0)
+
+static void asusec_keys_report_key(struct input_dev *dev, unsigned code,
+				   unsigned key, bool value)
+{
+	input_event(dev, EV_MSC, MSC_SCAN, code);
+	input_report_key(dev, key, value);
+	input_sync(dev);
+}
+
+static int asusec_keys_process_key(struct input_dev *dev, u8 code)
+{
+	unsigned key;
+
+	key = 0;
+	if (code < dev->keycodemax) {
+		unsigned short *map = dev->keycode;
+		key = map[code];
+	}
+	if (!key)
+		key = KEY_UNKNOWN;
+
+	asusec_keys_report_key(dev, code, key, 1);
+	asusec_keys_report_key(dev, code, key, 0);
+
+	return NOTIFY_OK;
+}
+
+static int asusec_keys_notify(struct notifier_block *nb,
+			      unsigned long action, void *data_)
+{
+	struct asusec_keys_data *priv = container_of(nb, struct asusec_keys_data, nb);
+	u8 *data = data_;
+
+	if (action & ASUSEC_SMI_MASK)
+		return NOTIFY_DONE;
+
+	if (action & ASUSEC_SCI_MASK)
+		return asusec_keys_process_key(priv->xidev, data[2]);
+
+	return NOTIFY_DONE;
+}
+
+static void asusec_keys_setup_keymap(struct input_dev *dev,
+				    const unsigned short *kmap,
+				    size_t kmap_size)
+{
+	unsigned short *keycode = dev->keycode;
+	size_t i;
+
+	input_set_capability(dev, EV_MSC, MSC_SCAN);
+	input_set_capability(dev, EV_KEY, KEY_UNKNOWN);
+
+	for (i = 0; i < kmap_size; ++i) {
+		unsigned code = kmap[i];
+		if (!code)
+			continue;
+
+		__set_bit(code, dev->keybit);
+		keycode[i] = code;
+	}
+}
+
+static int asusec_keys_probe(struct platform_device *dev)
+{
+	const struct asusec_info *ec = asusec_cell_to_ec(dev);
+	struct i2c_client *parent = to_i2c_client(dev->dev.parent);
+	struct asusec_keys_data *priv;
+	int ret;
+
+	priv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(dev, priv);
+	priv->ec = ec;
+
+	priv->xidev = devm_input_allocate_device(&dev->dev);
+	if (!priv->xidev)
+		return -ENOMEM;
+
+	priv->xidev->name = devm_kasprintf(&dev->dev, GFP_KERNEL,
+					   "%s Keyboard Ext", ec->model);
+	priv->xidev->phys = devm_kasprintf(&dev->dev, GFP_KERNEL,
+					   "i2c-%u-%04x",
+					   i2c_adapter_id(parent->adapter),
+					   parent->addr);
+
+	INPUT_SETUP_KEYMAP(priv->xidev, priv->keymap, asusec_dock_ext_keys);
+
+	ret = input_register_device(priv->xidev);
+	if (ret < 0) {
+		dev_err(&dev->dev, "failed to register extension keys: %d\n", ret);
+		return ret;
+	}
+
+	priv->nb.notifier_call = asusec_keys_notify;
+	ret = asusec_register_notifier(ec, &priv->nb);
+
+	return ret;
+}
+
+static int asusec_keys_remove(struct platform_device *dev)
+{
+	struct asusec_keys_data *priv = platform_get_drvdata(dev);
+
+	asusec_unregister_notifier(priv->ec, &priv->nb);
+
+	return 0;
+}
+
+static struct platform_driver asusec_keys_driver = {
+	.driver.name = "asusec-ext-keys",
+	.probe = asusec_keys_probe,
+	.remove = asusec_keys_remove,
+};
+
+module_platform_driver(asusec_keys_driver);
+
+MODULE_AUTHOR("Michał Mirosław <mirq-linux@rere.qmqm.pl>");
+MODULE_DESCRIPTION("ASUS Transformer Pad multimedia keys driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/serio/Kconfig b/drivers/input/serio/Kconfig
index 21488c048fa3..16cfae344ce5 100644
--- a/drivers/input/serio/Kconfig
+++ b/drivers/input/serio/Kconfig
@@ -96,6 +96,21 @@ config SERIO_RPCKBD
 	  To compile this driver as a module, choose M here: the
 	  module will be called rpckbd.
 
+config SERIO_ASUSEC
+	tristate "Asus Transformer Pad Dock's keyboard and touchpad controller"
+	depends on MFD_ASUSEC
+	help
+	  Say Y here if you want to use the keyboard and/or touchpad on
+	  Asus Transformed Pad's Mobile Dock.
+
+	  For keyboard support you also need atkbd driver.
+
+	  For touchpad support you also need psmouse driver with Elantech
+	  touchpad option enabled.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called asusec-kbc.
+
 config SERIO_AT32PSIF
 	tristate "AVR32 PSIF PS/2 keyboard and mouse controller"
 	depends on AVR32
diff --git a/drivers/input/serio/Makefile b/drivers/input/serio/Makefile
index 767bd9b6e1ed..8965893ea31f 100644
--- a/drivers/input/serio/Makefile
+++ b/drivers/input/serio/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_SERIO_CT82C710)	+= ct82c710.o
 obj-$(CONFIG_SERIO_RPCKBD)	+= rpckbd.o
 obj-$(CONFIG_SERIO_SA1111)	+= sa1111ps2.o
 obj-$(CONFIG_SERIO_AMBAKMI)	+= ambakmi.o
+obj-$(CONFIG_SERIO_ASUSEC)	+= asusec-kbc.o
 obj-$(CONFIG_SERIO_AT32PSIF)	+= at32psif.o
 obj-$(CONFIG_SERIO_Q40KBD)	+= q40kbd.o
 obj-$(CONFIG_SERIO_GSCPS2)	+= gscps2.o
diff --git a/drivers/input/serio/asusec-kbc.c b/drivers/input/serio/asusec-kbc.c
new file mode 100644
index 000000000000..d764e63ea304
--- /dev/null
+++ b/drivers/input/serio/asusec-kbc.c
@@ -0,0 +1,141 @@
+/*
+ * ASUS EC - keyboard and touchpad
+ *
+ * This looks suspiciously similar to i8042, but wrapped in
+ * I2C/SMBus packets.
+ *
+ * Written by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
+ *
+ * Copyright (C) 2017 Michał Mirosław
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/i8042.h>
+#include <linux/mfd/asusec.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serio.h>
+#include <linux/slab.h>
+
+struct asusec_kbc_data
+{
+	struct notifier_block	  nb;
+	const struct asusec_info *ec;
+	struct serio		 *sdev[2];
+};
+
+static int asusec_kbc_notify(struct notifier_block *nb,
+			     unsigned long action, void *data_)
+{
+	struct asusec_kbc_data *priv = container_of(nb, struct asusec_kbc_data, nb);
+	struct serio *port = NULL;
+	unsigned n;
+	u8 *data = data_;
+
+	if (action & (ASUSEC_SMI_MASK|ASUSEC_SCI_MASK))
+		return NOTIFY_DONE;
+	else if (action & ASUSEC_AUX_MASK)
+		port = priv->sdev[1];
+	else if (action & (ASUSEC_KBC_MASK|ASUSEC_KEY_MASK))
+		port = priv->sdev[0];
+	else
+		return NOTIFY_DONE;
+
+	n = data[0] - 1;
+	data += 2;
+	while (n--)
+		serio_interrupt(port, *data++, 0);
+
+	return NOTIFY_OK;
+}
+
+static int asusec_serio_write(struct serio *port, unsigned char data)
+{
+	const struct asusec_info *ec = port->port_data;
+
+	return asusec_i2c_command(ec, (data << 8) | port->id.extra);
+}
+
+static int asusec_register_serio(struct platform_device *dev, int idx,
+				 const char *name, int cmd)
+{
+	struct asusec_kbc_data *priv = platform_get_drvdata(dev);
+	struct i2c_client *parent = to_i2c_client(dev->dev.parent);
+	struct serio *port = kzalloc(sizeof(*port), GFP_KERNEL);
+
+	if (!port) {
+		dev_err(&dev->dev, "No memory for serio%d\n", idx);
+		return -ENOMEM;
+	}
+
+	priv->sdev[idx] = port;
+	port->dev.parent = &dev->dev;
+	port->id.type = SERIO_8042;
+	port->id.extra = cmd & 0xFF;
+	port->write = asusec_serio_write;
+	port->port_data = (void *)priv->ec;
+	snprintf(port->name, sizeof(port->name), "%s %s",
+		 priv->ec->model, name);
+	snprintf(port->phys, sizeof(port->phys), "i2c-%u-%04x/serio%d",
+		 i2c_adapter_id(parent->adapter), parent->addr, idx);
+
+	serio_register_port(port);
+
+	return 0;
+}
+
+static int asusec_kbc_probe(struct platform_device *dev)
+{
+	const struct asusec_info *ec = asusec_cell_to_ec(dev);
+	struct asusec_kbc_data *priv;
+	int ret;
+
+	priv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(dev, priv);
+	priv->ec = ec;
+
+	ret = asusec_register_serio(dev, 0, "Keyboard", 0);
+	if (ret < 0)
+		return ret;
+
+	ret = asusec_register_serio(dev, 1, "Touchpad", I8042_CMD_AUX_SEND);
+	if (ret < 0) {
+		serio_unregister_port(priv->sdev[0]);
+		return ret;
+	}
+
+	priv->nb.notifier_call = asusec_kbc_notify;
+	ret = asusec_register_notifier(ec, &priv->nb);
+
+	return ret;
+}
+
+static int asusec_kbc_remove(struct platform_device *dev)
+{
+	struct asusec_kbc_data *priv = platform_get_drvdata(dev);
+
+	asusec_unregister_notifier(priv->ec, &priv->nb);
+	serio_unregister_port(priv->sdev[1]);
+	serio_unregister_port(priv->sdev[0]);
+
+	return 0;
+}
+
+static struct platform_driver asusec_kbc_driver = {
+	.driver.name = "asusec-kbc",
+	.probe = asusec_kbc_probe,
+	.remove = asusec_kbc_remove,
+};
+
+module_platform_driver(asusec_kbc_driver);
+
+MODULE_AUTHOR("Michał Mirosław <mirq-linux@rere.qmqm.pl>");
+MODULE_DESCRIPTION("ASUS Transformer Pad Dock keyboard+touchpad controller driver");
+MODULE_LICENSE("GPL");
-- 
2.14.2

